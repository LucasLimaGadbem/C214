"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MemoizedCompareArrays = exports.CompareArrays = void 0;
const errors_1 = require("../core/errors");
const schema_validation_1 = require("../core/schema-validation");
const value_comparison_1 = require("../core/value-comparison");
const memoization_1 = require("../utils/memoization");
/**
 * Compares two arrays and returns whether they are equal
 *
 * @param firstArray - First array to compare
 * @param secondArray - Second array to compare
 * @param options - Optional comparison options (strict, circularReferences, pathFilter, schemaValidation)
 * @returns True if arrays are equal, false otherwise
 */
const CompareArrays = (firstArray, secondArray, options = {}) => {
    // Handle falsy cases
    if (!Array.isArray(firstArray) || !Array.isArray(secondArray)) {
        return false;
    }
    // Perform schema validation if specified
    if (options.schemaValidation) {
        // Convert arrays to objects for schema validation if schemas are provided
        if (options.schemaValidation.firstObjectSchema || options.schemaValidation.secondObjectSchema) {
            const firstObject = { items: firstArray };
            const secondObject = { items: secondArray };
            // Wrap the array schemas inside an object with 'items' property
            const wrappedFirstSchema = options.schemaValidation.firstObjectSchema
                ? { items: [options.schemaValidation.firstObjectSchema] }
                : undefined;
            const wrappedSecondSchema = options.schemaValidation.secondObjectSchema
                ? { items: [options.schemaValidation.secondObjectSchema] }
                : undefined;
            const wrappedSchemaValidation = {
                firstObjectSchema: wrappedFirstSchema,
                secondObjectSchema: wrappedSecondSchema,
                throwOnValidationFailure: options.schemaValidation.throwOnValidationFailure
            };
            // Run the schema validation
            (0, schema_validation_1.ValidateObjectsAgainstSchemas)(firstObject, secondObject, wrappedSchemaValidation);
        }
    }
    // Extract options
    const { circularReferences = 'error' } = options;
    // If the arrays are the same object, they're equal
    if (firstArray === secondArray) {
        return true;
    }
    // Check for obvious circular references in the top-level arrays
    if (circularReferences === 'error') {
        // Create a simple check for the most direct circular reference cases
        for (let i = 0; i < firstArray.length; i++) {
            if (firstArray[i] === firstArray) {
                throw new errors_1.CircularReferenceError(`[${i}]`);
            }
        }
        for (let i = 0; i < secondArray.length; i++) {
            if (secondArray[i] === secondArray) {
                throw new errors_1.CircularReferenceError(`[${i}]`);
            }
        }
    }
    try {
        // Use the unified depth handling function
        return (0, value_comparison_1.handleDepthComparison)(firstArray, secondArray, '', options, true, false) === true;
    }
    catch (error) {
        if (error instanceof errors_1.CircularReferenceError) {
            if (circularReferences === 'error') {
                throw error;
            }
            // If circularReferences is 'ignore' and we're still throwing, something went wrong
            return false;
        }
        throw error;
    }
};
exports.CompareArrays = CompareArrays;
/**
 * Memoized version of CompareArrays
 */
exports.MemoizedCompareArrays = (0, memoization_1.Memoize)(exports.CompareArrays);

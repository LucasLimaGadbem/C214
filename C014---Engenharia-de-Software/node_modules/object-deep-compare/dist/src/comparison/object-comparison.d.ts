import { ComparisonOptions, CompatibleObject } from '../types';
/**
 * Compares the properties of two objects (deep comparison)
 * Returns an array, each element is the path of a property that is different
 *
 * @param firstObject - First object to compare
 * @param secondObject - Second object to compare
 * @param pathOfConflict - Starting path for conflict (used in recursion)
 * @param options - Comparison options
 * @return Array of conflict paths
 */
export declare const CompareValuesWithConflicts: <T extends Record<string, any>, U extends Record<string, any>>(firstObject: T, secondObject: U, pathOfConflict?: string, options?: ComparisonOptions) => string[];
/**
 * Type guard that checks if two objects are equal
 * Can be used to narrow types in conditional branches
 *
 * @param firstObject - First object to compare
 * @param secondObject - Second object to compare
 * @param options - Optional comparison options
 * @returns Type predicate indicating if the objects are equal
 */
export declare const ObjectsAreEqual: <T extends Record<string, unknown>, U extends Record<string, unknown>>(firstObject: T | null | undefined, secondObject: U | null | undefined, options?: ComparisonOptions) => firstObject is (T & U);
/**
 * Checks if the second object is a subset of the first object
 * This is useful for checking if an object satisfies a specific interface
 *
 * @param firstObject - Object to check against
 * @param secondObject - Object that should be a subset
 * @param options - Optional comparison options
 * @returns Boolean indicating if secondObject is a subset of firstObject
 */
export declare const IsSubset: <T extends Record<string, unknown>, U extends Record<string, unknown>>(firstObject: T | null | undefined, secondObject: U | null | undefined, options?: ComparisonOptions) => boolean;
/**
 * Gets the common type structure between two objects
 * Useful for understanding what properties are shared between objects
 *
 * @param firstObject - First object to compare
 * @param secondObject - Second object to compare
 * @returns A new object containing only common properties with their types
 */
export declare const GetCommonStructure: <T extends Record<string, unknown>, U extends Record<string, unknown>>(firstObject: T | null | undefined, secondObject: U | null | undefined) => Partial<CompatibleObject<T, U>>;
/**
 * Memoized version of CompareValuesWithConflicts
 */
export declare const MemoizedCompareValuesWithConflicts: <T extends Record<string, any>, U extends Record<string, any>>(firstObject: T, secondObject: U, pathOfConflict?: string, options?: ComparisonOptions) => string[];
